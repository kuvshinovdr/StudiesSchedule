# StudiesSchedule
Учебный проект. Составление расписаний занятий.

## Общая схема работы

1. Конфигурация (разбор параметров командной строки).
1. Чтение исходных данных.
1. Составление расписания.
1. Сохранение результатов работы.

Составление расписания может занять значительное время, поэтому следует выводить уведомления о прогрессе в процессе работы.
Кроме того, можно засечь время, понадобившееся для получения результата.


## Конфигурация

Параметры командной строки:

- Количество попыток составления расписания.
- Пути к входным файлам.
- Путь, куда сохранять выход.

Итак, ключи:

- **--help**: вывод справки;
- **--version**: вывод информации о версии;
- **--input**: задать путь к директории с файлами входных данных;
- **--output**: задать путь к директории с файлами результатов;
- **--rooms**: задать имя файла со списком аудиторий;
- **--stuff**: задать имя файла со списком преподавателей;
- **--groups**: задать имя файла со списком групп;
- **--subjects**: задать назначения предметов;
- **--timeslots**: список временных слотов в порядке приоритетности выбора; 
- **--forbidden**: запрещённые временные слоты для аудиторий, групп и преподавателей.


## На входе

В формате CSV:

- Список аудиторий.
- Список групп.
- Список преподавателей.
- Список временных слотов в порядке приоритетности назначения (столбцы: день недели, номер в течении дня).
- Список предметов с указанием групп и преподавателей.
- Списки запрещённых временных слотов для: аудиторий, групп и преподавателей.

В данный момент не учитывается возможность разной вместимости аудиторий и проведения предметов для потоков или, напротив, подгрупп.
Также не учитывается возможность дополнительных ограничений по связке предмет — аудитория (наличие проектора, лаборатории и т.п.).

## На выходе

В формате CSV:

- Недельное расписание каждой группы (строки — временные слоты, столбцы: аудитория, предмет, преподаватель).
- Недельное расписание каждого преподавателя (строки — временные слоты, столбцы: аудитория, предмет, группа).
- Недельное расписание каждой аудитории (строки — временные слоты, столбцы: предмет, группа, преподаватель).
- Полный список вычисленных назначений (может использоваться в отладочных целях).
- Список выпавших назначений (которые не удалось разместить в имеющиеся временные слоты).

## Формализация задачи

Объекты:

- Временной слот
- Аудитория
- Группа
- Преподаватель
- Предмет

Назначение: временной слот — аудитория — группа — преподаватель — предмет.

Ограничение(назначение1, назначение2):

назначение1.слот ≠ назначение2.слот ∨
(назначение1.преподаватель ≠ назначение2.преподаватель ∧ назначение1.аудитория ≠ назначение2.аудитория)

Задачу можно разложить на две задачи назначений:

1. Назначить время предметам.
1. Назначить аудитории.

Можно представить эти задачи в форме задач о правильной вершинной раскраске графа (желательно использующей минимальное доступное количество цветов).

### Первая задача

Назначение имеет вид: вершина(группа — преподаватель — предмет) — цвет(временной слот).

Вершины являются соседними, если у них совпадают группа или преподаватель.

### Вторая задача

Назначение имеет вид: вершина(группа — преподаватель — предмет — временной слот) — цвет(аудитория).

Вершины являются соседними, если у них совпадают временные слоты.

## Алгоритм

Предполагается использовать полиномиальный алгоритм, дающий субоптимальное решение за приемлемое время.
Его можно запускать для какого-то начального (неверного) "решения", которое он будет пытаться исправить.
Это "решение" можно получить с помощью эвристики или назначить случайно.
Разные начальные "решения" в общем случае будут давать разные реальные решения в результате работы алгоритма, что позволяет сделать несколько попыток найти решение:

- с минимальным числом назначений, не уложившихся в заданные временные слоты (в принципе, мы хотим, чтобы таких вовсе не было);
- более равномерно или более компактно распределяющее нагрузку, например, с минимальным числом "окон";
- удовлетворяющее произвольным дополнительным ограничениям.

См. также [пример подобного алгоритма](https://evetro.wordpress.com/2017/12/03/an-algorithm-for-graph-proper-coloring-2/) для вычисления правильной вершинной раскраски графа.

Общая идея простого алгоритма заключается в повторении следующих итераций:

1. Завести множество соседей перекрашенных вершин *A* := Ø.
2. Упорядочить список конфликтов *C* (по убыванию числа конфликтов *n*).
3. Для каждой тройки (*v*, *n*, *c*) из *C*, если *v* не принадлежит *A*, то:
- Назначить вершине *v* цвет *c*.
- Пополнить *A* соседями *v*.



